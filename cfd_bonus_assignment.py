# -*- coding: utf-8 -*-
"""CFD-Bonus Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/166Urkwrc7yt4MUcOk_qryZnm47yvfvJc
"""

"Assignment 5 - Numerical computaion of incompressible flow inside venturi"
"Submitted by Raghavendra K H - 23M0013"

#imports
import numpy as np # Import NumPy library for numerical computations
import matplotlib.pyplot as plt # Import Matplotlib library for plotting

# Grid specification
nx = 101  # Number of grid points in x-direction
ny = 26   # Number of grid points in y-direction
Lx = 1.0  # Length of the domain in x-direction
Ly = 1.0  # Length of the domain in y-direction

#coordinates of computational domain
zeta = np.linspace(0, Lx, nx)  # zeta (x-direction)
eta = np.linspace(0, Ly, ny)  # eta (y-direction)

 #Create a meshgrid of eta and zeta coordinates
E,Z = np.meshgrid(eta,zeta)
# Initialize x and y array with zeros
x = np.zeros(np.shape(Z))
y = np.zeros(np.shape(E))

e= [] # create empty list of error

"mapped value of x and y from computaional domain to pysical domain"
x = 4*Z
for i in range(nx):
  for j in range(ny):
    if 0.25 <= zeta[i] <= 0.75:
      y[i,j] = E[i,j]+(1-E[i,j])*(1-np.cos((4*zeta[i]-1)*np.pi))/10
    else:
      y[i,j] = E[i,j]

# Function to calculate psi
def calculate_psi():
  p_nw = np.zeros((nx, ny))
# Initialize arrays A, B, and C with zeros
  A = np.zeros((nx, ny))
  B = np.zeros((nx, ny))
  C = np.zeros((nx, ny))

  dzeta = 1/(nx-1)
  deta = 1/(ny-1)

 # Set boundary condition
  p_nw[:, 25] = 100
  for i in range(nx):
    p_nw[i, :] = np.linspace(p_nw[i, 0], p_nw[i, 25], 26)

 # Calculate coefficients A, B, and C based on given conditions
  for i in range(nx):
    for j in range(ny):
      if 0.25 <= zeta[i] <= 0.75:
        A[i,j] = (10*np.pi*(1-y[i,j])*np.sin(np.pi*x[i,j]))/(9-np.cos(np.pi*x[i,j]))**2
        B[i,j] = (10*np.pi**2*(y[i,j]-1)*(np.sin(np.pi*x[i,j])**2+1-9*np.cos(np.pi*x[i,j])))/(9-np.cos(np.pi*x[i,j]))**3
        C[i,j] = (10/(9-np.cos(np.pi*x[i,j])))**2
      else:
        A[i,j] = 0
        B[i,j] = 0
        C[i,j] = 1


  t0 = 0 # Initialize iteration counter as 0

  t_last = 3000 # Set maximum number of iterations

# Iterative solution of the Poisson equation
  while t0 <= t_last:
    p_old = p_nw.copy()
# Update psi values using second order ftcs scheme
    for i in range(1,nx-1):
      for j in range(1,ny-1):
        E = (p_old[i+1,j+1] + p_nw[i-1,j-1] - p_old[i-1,j+1] - p_old[i+1,j-1])/(4*dzeta*deta)
        F = (p_old[i,j+1] - p_nw[i,j-1])/(2*deta)

        p_nw[i,j] = ((0.0625 * (p_old[i+1,j] + p_nw[i-1,j])/dzeta**2) + (A[i,j] * E * 0.5) + (B[i,j] * F) + ((p_old[i,j+1] + p_nw[i,j-1])*A[i,j]**2/deta**2) +
                      ((p_old[i,j+1] + p_nw[i,j-1])*C[i,j]/deta**2))/((0.125/dzeta**2) + (2*A[i,j]**2/deta**2) + (2*C[i,j]/deta**2))

    error= np.sum(np.abs(p_nw - p_old))
    e.append(np.log10(np.max(error)))
    if np.max(error) < 1e-5:
      break

    t0 += 1 # Increment iteration counter

  return p_nw , e # Return the calculated psi array
psi, e1 = calculate_psi()

# Function to calculate velocity components
def plot_results():
  dx = 4/(nx-1)  # Calculate grid spacing in x-direction
  dy = 1/(ny-1)  # Calculate grid spacing in y-direction
  u = np.zeros((nx, ny)) #intialize x-velocity component array
  v = np.zeros((nx, ny)) #ntialize y-velocity component array
  dpsi_dx, dpsi_dy = np.gradient(psi, dy, dx)
  u = dpsi_dy # Calculate x-velocity component
  v = -dpsi_dx # Calculate y-velocity component

  return u , v
u1,v1 =plot_results() # Calculate velocity components

V_total = np.sqrt(u1**2 + v1**2) # Calculate Total velocity components

# Plotting log10(error) vs. no of iteration
fig, axs = plt.subplots(1, 1)
axs.plot(range(len(e1)), e1,'.',color='green', )
axs.set_xlabel('Iteration')
axs.set_ylabel('Log10(Error)')
axs.set_title('log(10)Error vs. Number of Iteration')
axs.grid(True)
plt.show()

#Plot variations of ψ along the mid-vertical-lines at locations x = 0.5, x = 1.0, x = 2.0, x = 3.0, x = 3.5.
fig, axs = plt.subplots(1, 1)
axs.plot(psi[12], y[12], 'D-', label="x=0.5")
axs.plot(psi[25], y[25], '*-', label="x=1.0")
axs.plot(psi[50], y[50], ':', label="x=2.0")
axs.plot(psi[75], y[75], '--', label="x=3.0")
axs.plot(psi[87], y[87], '-', label="x=3.5")
axs.set_title("Variation of ψ along the mid vertical lines")
axs.set_xlabel("ψ")
axs.set_ylabel("y")
axs.legend()
plt.show()

#Plot variations of u along the mid-vertical-lines at locations x = 0.5, x = 1.0, x = 2.0, x = 3.0, x = 3.5.
fig, axs = plt.subplots(1, 1)
axs.plot(u1[12], y[12], 'D-', label="x=0.5")
axs.plot(u1[25], y[25], '*-', label="x=1.0")
axs.plot(u1[50], y[50], ':', label="x=2.0")
axs.plot(u1[75], y[75], '--', label="x=3.0")
axs.plot(u1[87], y[87], '-', label="x=3.5")
axs.set_title("Variation of u(x-component of  velocity) along the mid vertical lines")
axs.set_xlabel("u")
axs.set_ylabel("y")
axs.legend()
plt.show()

#Plot variations of v along the mid-vertical-lines at locations x = 0.5, x = 1.0, x = 2.0, x = 3.0, x = 3.5.
fig, axs = plt.subplots(1, 1)
axs.plot(v1[12], y[12], 'D-', label="x=0.5")
axs.plot(v1[25], y[25], '*-', label="x=1.0")
axs.plot(v1[50], y[50], ':', label="x=2.0")
axs.plot(v1[75], y[75], '--', label="x=3.0")
axs.plot(v1[87], y[87], '-', label="x=3.5")
axs.set_title("Variation of v (y-component of velocity) along the mid vertical lines")
axs.set_xlabel("v")
axs.set_ylabel("y")
axs.legend()
plt.show()

#Plot variations of total velocity along the mid-vertical-lines at locations x = 0.5, x = 1.0, x = 2.0, x = 3.0, x = 3.5.
fig, axs = plt.subplots(1, 1)
axs.plot(V_total[12], y[12], 'D-', label="x=0.5")
axs.plot(V_total[25], y[25], '*-', label="x=1.0")
axs.plot(V_total[50], y[50], ':', label="x=2.0")
axs.plot(V_total[75], y[75], '--', label="x=3.0")
axs.plot(V_total[87], y[87], '-', label="x=3.5")
axs.set_title("Variation of Total velocity along mid vertical lines")
axs.set_xlabel("V_total")
axs.set_ylabel("y")
axs.legend()
plt.show()